\documentclass[NET,english,aspectratio=169,notitleframe,draft]{tumbeamer}

%settings
\usepackage[utf8]{inputenc}
\usepackage{pgfplotstable}
\usepackage{marvosym}
\usepackage{filecontents}
\usepackage{packages}
\usepackage{beamermods}

\usepackage[backend=bibtex, style=ieee]{biblatex}

\usepackage{csquotes}

\usetikzlibrary{calc}
\usetikzlibrary{arrows.meta}


% For lecture mode (use package option 'lecture'):
%\lecture[GRNVS]{Grundlagen Rechnernetze und Verteilte Systeme}
%\module{IN0010}
%\semester{SoSe\,2016}
%\assistants{Johannes Naab, Stephan Günther, Maurice Leclaire}

\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{tumcolor}
\usepackage{tumcolors}
\usepackage{textpos}


\usepackage{pgfpages}
\usepackage{ifthen}
% ============================================================================
% jobname solution
% ============================================================================
\newif\ifsolution%
\ifthenelse{\equal{\detokenize{notes}}{\jobname}}{%
\setbeameroption{show notes on second screen=bottom}
\setbeamercolor{note page}{bg=white, fg=black}
\setbeamercolor{note title}{bg=white!95!black, fg=black}
}{
}

%\xdefinecolor{orange}{cmyk}{0,0.65,0.95,0} 
%\xdefinecolor{dblue}{cmyk}{1,0.54,0.04,0.19}
%\xdefinecolor{blue}{cmyk}{1,0.43,0,0}  
%\xdefinecolor{lblue}{cmyk}{0.65,0.19,0.01,0.04}
%\xdefinecolor{green} {cmyk}{0.35,0,1,0.2} 
%xdefinecolor{yellow}{rgb}{1.00,0.71,0.00} 
%\colorlet{lgtorange}{orange!20} 
%\colorlet{lgtdblue}{dblue!20} 
%\colorlet{lgtblue}{blue!20} 
%\colorlet{lgtlblue}{lblue!20} 
%colorlet{lgtgreen}{green!20} 
%\colorlet{lgtyellow}{yellow!20}

\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}
\usepackage{cancel}
\usepackage{minted}


\addbibresource{lit.bib}


% For beamer mode (default):
 % jeder von dem wir hier irgendwas nehmen, alphabetisch sortiert
\author[Paul Emmerich, Simon Ellmann, Sebastian Voit]{\textbf{Paul Emmerich}, \textbf{Simon Ellmann}, \textbf{Sebastian Voit},\\ Fabian Bonk, Alex Egger, Alexander Frank, Thomas Günzel,\\ Stefan Huber,  Maximilian Pudelko, Maximilian Stadlmeier}
\title{Safe and Secure Drivers in High-Level Languages}
\date{December 29, 2018}

\begin{document}

\setbeamertemplate{footline}{}
  \begin{frame}[c,noframenumbering]
%    \begin{tikzpicture}[overlay,remember picture]
%      \node[opacity=0.5,anchor=south east] at ($(current page.south east)+(-1,-1)$) {%
%    \includegraphics[width=.4\textwidth]{pics/TUM_Uhrenturm.png}};
%  \end{tikzpicture}
  \centering%
  \Large%
  \strut\textcolor{TUMBlue}{\inserttitle}%
  \\[4ex]%
  \normalsize%
  \strut\insertauthor%
  \\[2ex]%
  \footnotesize%
  \insertdate%
  \\[4ex]%
  \ifdefined\departmentname%
    \ifdefined\chairname%
      \chairname\\%
    \fi%
    \departmentname\\%
  \fi%
  \TUMname\\%
\end{frame}

  \begin{frame}[c,noframenumbering]
%    \begin{tikzpicture}[overlay,remember picture]
%      \node[opacity=0.5,anchor=south east] at ($(current page.south east)+(-1,-1)$) {%
%    \includegraphics[width=.4\textwidth]{pics/TUM_Uhrenturm.png}};
%  \end{tikzpicture}
  \centering%
  \Large%
  \strut\textcolor{TUMBlue}{\inserttitle}%
  \\[4ex]%
  \normalsize%
  \strut{}\bfseries Paul Emmerich$^1$, Simon Ellmann$^2$, Sebastian Voit$^3$,\\ Fabian Bonk$^4$, Alex Egger$^5$, Alexander Frank$^6$, Thomas Günzel$^7$,\\ Stefan Huber$^8$, Maximilian Pudelko$^9$, Maximilian Stadlmeier$^{10}$ \normalfont %
  \\[2ex]%
  \footnotesize%
  $^1$C, thesis advisor\hspace{1em}
  $^2$Rust\hspace{1em}
  $^3$Go\hspace{1em}
  $^4$OCaml\hspace{1em}
  $^5$Haskell\hspace{1em}\\
  $^6$Latency measurements\hspace{1em}
  $^7$Swift\hspace{1em}
  $^8$IOMMU\hspace{1em}
  $^9$VirtIO driver\hspace{1em}
  $^{10}$C\#\hspace{1em}
  \\[4ex]%
    \ifdefined\departmentname%
    \ifdefined\chairname%
      \chairname\\%
    \fi%
    \departmentname\\%
  \fi%
  \TUMname\\%
\end{frame}
\setbeamertemplate{footline}[tumfootline]

\begin{frame}{About us}
\begin{columns}
\begin{column}{0.8\textwidth}
\emph{Paul}
\begin{itemize}
\item PhD student at Technical University of Munich
\item Researching performance of packet processing systems
\end{itemize}
\vfill
\emph{Simon}
\begin{itemize}
\item Rust driver as bachelor's thesis, now HiWi/research assistant
\end{itemize}
\emph{Sebastian}
\begin{itemize}
\item Rust driver as bachelor's thesis
\end{itemize}
\emph{Everyone else}
\begin{itemize}
\item Did a thesis with Paul as advisor
\end{itemize}
\end{column}
\begin{column}{0.15\textwidth}
%\begin{tikzpicture}[remember picture,overlay]
%	\node[xshift=-2.5cm,yshift=-3cm] at (current page.north east) {\includegraphics[width=0.2\textwidth]{pics/paul.jpg}};
%	\node[xshift=-2.5cm,yshift=-3cm] at (current page.south east) {\includegraphics[width=0.2\textwidth]{pics/simon.jpg}};
\includegraphics[width=0.8\textwidth]{pics/paul.jpg}\\
\includegraphics[width=0.8\textwidth]{pics/simon.jpg}\\
\includegraphics[width=0.8\textwidth]{pics/sebastian.jpg}
%\end{tikzpicture}
\end{column}
\end{columns}
\end{frame}


\begin{frame}{Network drivers}
\centering\includegraphics[width=0.60\textwidth]{pics/nic3}\\
\vspace{-1em}\tiny{Intel XL710 [Picture: Intel.com]}
\end{frame}

\begin{frame}{The ixy project}
\begin{itemize}
\item Attempt to write a simple yet fast user space network driver
\item It's a user space driver you can easily understand and read
\item $\approx$ 1,000 lines of C code, full of references to datasheets and specs
\item Supports Intel ixgbe NICs %(82599, X540, Xeon D, ...)
\item New: supports VirtIO NICs (qemu/kvm and VirtualBox, we got a Vagrant setup!)
\item Check it out on GitHub: \url{https://github.com/emmericp/ixy}
\end{itemize}
\end{frame}

\begin{frame}{Hardware: Intel \texttt{ixgbe} family (10\,Gbit/s)}
\begin{itemize}
\item \texttt{ixgbe} family: 82599ES (aka X520), X540, X550, Xeon D embedded NIC
\item Commonly found in servers or as on-board chips
\item Very good datasheet publicly available
\vspace{1em}
\item Almost no logic hidden behind black-box firmware
%\item<2-> Black-box firmware contains almost no magic
\item<2-> Drivers for many newer NICs often just exchanges messages with the firmware
\item<2-> Here: all hardware features directly exposed to the driver
\end{itemize}
\end{frame}


\begin{frame}{Expectation: Beautiful C code}
\begin{itemize}
\item Why write a driver in C?
\pause
\vspace{1em}
\item Most drivers are written in C
\item C is the lowest common denominator of systems programming languages
\item C code can be beautiful
\item Everyone can read C?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Reality: C can be ugly}
\begin{minted}[autogobble]{c}
#define mystery_macro(ptr, type, member) ({\
	const typeof(((type*)0)->member)* __mptr = (ptr);\
	(type*)((char*)__mptr - offsetof(type, member));\
})
\end{minted}
\end{frame}

\begin{frame}[fragile]{Reality: C can be ugly}
\begin{minted}[autogobble]{c}
#define container_of(ptr, type, member) ({\
	const typeof(((type*)0)->member)* __mptr = (ptr);\
	(type*)((char*)__mptr - offsetof(type, member));\
})
\end{minted}
\end{frame}


\begin{frame}[fragile]{Reality: C can be ugly}
\begin{minted}[autogobble]{c}
#define container_of(ptr, type, member) ({\
	const typeof(((type*)0)->member)* __mptr = (ptr);\
	(type*)((char*)__mptr - offsetof(type, member));\
})
\end{minted}
\begin{itemize}
\item Allows some ``inheritance'' in C to abstract driver implementations
\item Virtually all C drivers use this macro
\item The Linux kernel contains $\approx$ 15,000 uses of this macro
\end{itemize}
\end{frame}

\begin{frame}{C can cause security problems}
\centering\includegraphics[trim={0 13cm 0 0},clip,width=0.65\textwidth]{pics/cve}

\footnotesize (...)

\centering\includegraphics[trim={0 0 0 17.5cm},clip,width=0.65\textwidth]{pics/cve}

\begin{itemize}
\item Screenshot from \url{https://www.cvedetails.com/}
\item Security bugs found in the Linux kernel in the last $\approx$ 20 years
\end{itemize}

\end{frame}


\begin{frame}{C can cause security problems}
\begin{itemize}
\item Not all bugs can be blamed on the language
\item Cutler et al. analyzed 65 CVEs categorized as code execution in the Linux kernel \footnote{C. Cutler, M. F. Kaashoek, and R. T. Morris, \emph{``The benefits and costs of writing a POSIX kernel in a high-level language''}, USENIX OSDI, 2018}
\end{itemize}
\pause
\begin{table}
\centering
\begin{tabular}{ l  r r l }
  \toprule
  Bug type & Num. & Perc. & Can be avoided by language? \\
  \midrule
  Various & 11 & 17\% & Unclear/Maybe \\
  Logic & 14 & 22\% & No \\
  Use-after-free & 8 & 12\% & Yes \\
  Out of bounds & 32 & 49\% & Yes (likely leads to panic) \\
  \bottomrule  
\end{tabular}
\caption{Code execution vulnerabilities in the Linux kernel identified by Cutler et al$^1$}
\end{table}
\end{frame}

\begin{frame}{Are there preventable bugs in drivers?}
\begin{itemize}
\item We looked at these 40 preventable bugs
\pause
\item 39 of them were in drivers (the other was in the Bluetooth stack)
\pause
\item 13 were in the Qualcomm WiFi driver
\end{itemize}
\end{frame}

\begin{frame}{Should you really write new code in C in 2019?}
\begin{itemize}
\item If you have a choice: probably not, no
\pause
\item User space drivers can be written in \emph{any} language!
\item But are all languages an equally good choice?
\item Is a JIT compiler or a garbage collector a problem in a driver?
\end{itemize}
\end{frame}

\setbeamertemplate{footline}{}
\begin{frame}{}
\centering\includegraphics[width=0.65\textwidth]{pics/allthe1}
\end{frame}

\begin{frame}{}
\centering\includegraphics[width=0.65\textwidth]{pics/allthe2}
\end{frame}

\begin{frame}{}
\centering\includegraphics[width=0.85\textwidth]{pics/theses}
\end{frame}
\setbeamertemplate{footline}[tumfootline]


\begin{frame}{Basics: How to talk to (modern) PCIe devices}
\begin{enumerate}
\item Memory-mapped IO (MMIO)
\item Direct memory access (DMA)
\item Interrupts
\end{enumerate}
\end{frame}

\begin{frame}{Basics: How to talk to (modern) PCIe devices}
\begin{enumerate}
\item Memory-mapped IO (MMIO)
\begin{itemize}
\item Magic memory area that is mapped to the device
\item Memory reads/writes are directly forwarded to the device
\item Usually used to expose device registers
\item User space drivers: \texttt{mmap} a magic file
\end{itemize}
\item[\color{TUMLightGray}2.] {\color{TUMLightGray} Direct memory access (DMA)}
\item[\color{TUMLightGray}3.] {\color{TUMLightGray} Interrupts}
\end{enumerate}
\end{frame}

\begin{frame}{Basics: How to talk to (modern) PCIe devices}
\begin{enumerate}
\item[\color{TUMLightGray}1.] {\color{TUMLightGray} Memory-mapped IO (MMIO)}
\item[2.] Direct memory access (DMA)
\begin{itemize}
\item Allows the device to read/write \emph{arbitrary} memory locations
\item User space drivers: figure out physical addresses, tell the device to write there
\end{itemize}
\item[\color{TUMLightGray}3.] {\color{TUMLightGray}  Interrupts}
\end{enumerate}
\end{frame}

\begin{frame}{Basics: How to talk to (modern) PCIe devices}
\begin{enumerate}
\item[\color{TUMLightGray}1.] {\color{TUMLightGray} Memory-mapped IO (MMIO)}
\item[\color{TUMLightGray}2.] {\color{TUMLightGray} Direct memory access (DMA)}
\item[3.] Interrupts
\begin{itemize}
\item This is how the device informs you about events
\item User space drivers: available via the Linux \texttt{vfio} subsystem
\item (Usually) not useful for high-speed network drivers 
\item We'll ignore interrupts here
\end{itemize}
\end{enumerate}
\end{frame}


\begin{frame}{Basics: How to write a user space driver in 4 simple steps}
\begin{itemize}
\item[1.] Unload kernel driver
\item[2.] \texttt{mmap} the PCIe MMIO address space
\item[3.] Figure out physical addresses for DMA
\item[4.] Write the driver
\end{itemize}
\end{frame}




\newmintinline[ccode]{c}{}
\newmintinline[bashcode]{c}{}

\begin{frame}[fragile=singleslide]{Find the device we want to use}
\begin{Verbatim}[commandchars=\\\{\}]
# lspci
03:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ ...
03:00.1 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ ...
\end{Verbatim}
\end{frame}

\begin{frame}[fragile=singleslide]{Find the device we want to use}
\begin{Verbatim}[commandchars=\\\{\}]
# lspci
\textbf{03:00.0} Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ ...
\textbf{03:00.1} Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ ...
\end{Verbatim}
\end{frame}

\begin{frame}[fragile=singleslide]{Unload the kernel driver}
\begin{minted}{bash}
echo 0000:03:00.1 > /sys/bus/pci/devices/0000:03:00.1/driver/unbind
\end{minted}
\end{frame}

\begin{frame}[fragile=singleslide]{\texttt{mmap} the PCIe configuration address space from user space}
\begin{minted}[autogobble]{c}
int fd = open("/sys/bus/pci/devices/0000:03:00.0/resource0", O_RDWR);
struct stat stat;
fstat(fd, &stat);
uint8_t* registers = (uint8_t*) mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE,
                                     MAP_SHARED, fd, 0);
\end{minted}
\end{frame}

\begin{frame}{Device registers}
\centering\includegraphics[width=0.75\textwidth]{pics/registers}
\end{frame}

\begin{frame}[fragile=singleslide]{Access registers: LEDs}
\begin{minted}[autogobble]{c}
#define LEDCTL 0x00200
#define LED0_BLINK_OFFS 7

uint32_t leds = *((volatile uint32_t*)(registers + LEDCTL));
*((volatile uint32_t*)(registers + LEDCTL)) = leds | (1 << LED0_BLINK_OFFS);
\end{minted}
\begin{itemize}
\item Memory-mapped IO: all memory accesses go directly to the NIC
\item One of the very few valid uses of \ccode{volatile} in C
\end{itemize}
\end{frame}


\begin{frame}{Handling packets via DMA}
\begin{itemize}
\item Packets are transferred via queue interfaces (often called rings)
\item Rings are configured via MMIO and accessed via by the device DMA
\item Rings (usually) contain pointers to packets, also accessed via DMA
\pause
\vspace{1em}
\item Details vary between different devices
\item This is not unique to NICs: most PCIe devices work in a similar manner
\end{itemize}
\end{frame}


\begin{frame}{Challenges for high-level languages}
\begin{itemize}
\item Access to \texttt{mmap} with the proper flags
\item Handle externally allocated memory in the language
\item Handle memory layouts/formats (i.e., access memory that looks like a given C struct)
\item Memory access semantics: memory barriers, volatile reads/writes
\end{itemize}
\end{frame}



\begin{frame}{C\#}
\end{frame}

\begin{frame}{Swift}
%\centering\includestandalone[scale=0.79]{figures/benchmarks-swift-alone}
%\centering\includestandalone[scale=0.82]{figures/benchmarks-swift-with-c}
%\centering\includestandalone[scale=0.77]{figures/benchmarks-swift-batching}
\end{frame}

\begin{frame}{OCaml}
\end{frame}

\begin{frame}{Haskell}
\end{frame}

\begin{frame}{Go}
\begin{itemize}
\item Compiled programming language developed by Google 
\item General purpose language but designed for distributed systems
\item<2-> A driver is not a distributed system
\item<3-> Then why even use Go?
\begin{itemize}
\item<4-> Runtime for:\\Garbage Collection\\Memory \& Type safety
%\item<4-> Simple yet powerful concurrency via goroutines	%not relevant ofr a single core driver
\item<4-> Large standard library
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Go for Drivers}
\begin{itemize}
\item Actually a lot like C in many aspects
%maybe include some code examples?
\item<2-> Main differences:
\begin{itemize}
\item<2-> No pointer arithmetic (managing DMA memory)
\item<2-> No volatile (memory barriers for register access)
\end{itemize}
\item<3-> What we do instead:
\begin{itemize}
\item<3-> Manage DMA memory via slices
\item<3-> Unsafe pointers: circumvent runtime\\
	$\rightarrow$ Physical address calculation \& with atomic.Load/Store register access
\item<3-> Ruleset for unsafe pointers to still be valid
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Rust}
\begin{itemize}
\item compiled systems programming language
\item aims to be memory safe (especially regarding concurrency), i.e.
\begin{itemize}
\item no race conditions,
\item no dangling pointers,
\item no undefined behaviour,
\item ...
\end{itemize}
\item unique ownership system and ruleset for moving/borrowing values
%\item highly efficient through zero-cost abstractions
\end{itemize}
\end{frame}

\begin{frame}{Rust's Ownership System}
\begin{itemize}
\item Three simple rules:
\begin{itemize}
\item Each value has a variable that is its owner.
\item There can only be one owner at a time.
\item When the owner goes out of scope, the value is freed.
\end{itemize}
\item Rules are enforced at compile-time
\item Ownership can be passed to another variable% by
%\begin{itemize}
%\item ``moving'' the value or by
%\item ``borrowing'' it through a reference
%\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Rust: Safe vs. Unsafe}
\begin{itemize}
\item not everything can be done in safe Rust
\item calling foreign functions and dereferencing raw pointers is always unsafe
\item many functions in Rust's standard library make use of unsafe code
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Rust}
\begin{itemize}
\item biggest challenge: memory handling inside and outside the driver
\end{itemize}
\begin{minted}{c}
fn set_reg32(&self, reg: u32, val: u32) {
  assert!(
    reg as usize <= self.len - 4 as usize,
    "memory access out of bounds"
  );

  unsafe {
    ptr::write_volatile((self.addr as usize + reg as usize) as *mut u32, val);
  }
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Rust}
% TODO: some packet code or graphic? forwarder?
\begin{itemize}
\item look at this nice code ...
\end{itemize}
\begin{minted}{c}
fn set_reg32(&self, reg: u32, val: u32) {
  assert!(
    reg as usize <= self.len - 4 as usize,
    "memory access out of bounds"
  );

  unsafe {
    ptr::write_volatile((self.addr as usize + reg as usize) as *mut u32, val);
  }
}
\end{minted}
\end{frame}

\begin{frame}{Performance comparison}
\centering\includestandalone[scale=0.82]{figures/benchmarks-all-throughput}
\end{frame}

\begin{frame}{Batching}
\centering\includestandalone[scale=0.85]{figures/benchmarks-all-batching}
\end{frame}

\begin{frame}{Performance comparison}
% TODO: observations and reasons/speculations for good/bad performance?
\begin{itemize}
\item Rust's throughput close to C, safe wrappers lead to more memory operations
\item Swift performs incredibly poor
\item ...
\end{itemize}
\end{frame}

\begin{frame}{Garbage collection and JIT compilation vs. latency}
\end{frame}


\begin{frame}{Restricting devices with the IOMMU}
\end{frame}

\begin{frame}{Look ma, no root}
\end{frame}


\begin{frame}{Why to write a user space network driver?}
\end{frame}

\begin{frame}{(Maybe) network stack of the future}
\end{frame}

\begin{frame}{Why? Features!}
\end{frame}

\begin{frame}{Example: hardware timestamping}
\end{frame}


\begin{frame}{Conclusion: Check out our code}
\centering \qrcode[height=3cm]{https://github.com/ixy-languages/ixy-languages}
\begin{itemize}
\item Meta-repository with links: \url{https://github.com/ixy-languages/ixy-languages}
\item Drivers are simple: don't be afraid of them
\item No kernel code needed :)
\end{itemize}
%\centering \Huge Q \& A
\end{frame}





\end{document}

